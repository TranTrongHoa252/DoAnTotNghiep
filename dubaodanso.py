# -*- coding: utf-8 -*-
"""DuBaoDanSo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rChgI70JXJ9Cpp6eRk3ldwT27uRuJ5cN
"""

# HỒI QUY ĐƠN BIẾN ĐƠN BIẾN
# Dự báo DanSoTB bằng cách sd dân số năm trước(lag1)

import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler

# 1) Đọc dữ liệu
def load_data(csv_path: str) -> pd.DataFrame:
    df = pd.read_csv(csv_path)
    df["Nam"] = df["Nam"].astype(int)

    # Quy đổi nghìn người → người
    df["DanSoTB"] = df["DanSoTB"] * 1000
    return df

# 2) Đơn biến AR(1): train + test + dự báo năm chọn
def ar1_train_test_forecast(
    df: pd.DataFrame,
    tinh: str,
    nam_chon: int,
    test_years: int = 2
):
    """
    Mô hình AR(1):
        DanSoTB_t = b0 + b1 * DanSoTB_(t-1)

    - Lọc theo tỉnh
    - Tạo biến trễ lag-1
    - Chuẩn hóa dữ liệu
    - Chia train/test theo thời gian
    - Đánh giá MAE, RMSE, R2
    - Dự báo DUY NHẤT cho năm nam_chon
    """

    # --- Lọc dữ liệu theo tỉnh ---
    g = df[df["Tinh"] == tinh].sort_values("Nam").copy()
    if g.empty:
        raise ValueError(f"Không tìm thấy tỉnh: {tinh}")

    # --- Tạo biến trễ ---
    g["DanSoTB_lag1"] = g["DanSoTB"].shift(1)
    gl = g.dropna(subset=["DanSoTB_lag1"]).reset_index(drop=True)

    # --- Giới hạn dữ liệu đến năm chọn ---
    gl_upto = gl[gl["Nam"] <= nam_chon].copy()
    if len(gl_upto) < test_years + 2:
        raise ValueError("Không đủ dữ liệu để chia train/test.")

    # --- Chia train / test theo thời gian ---
    train = gl_upto.iloc[:-test_years].copy()
    test = gl_upto.iloc[-test_years:].copy()

    X_train = train[["DanSoTB_lag1"]]
    y_train = train["DanSoTB"]

    X_test = test[["DanSoTB_lag1"]]
    y_test = test["DanSoTB"]

    # --- Chuẩn hóa ---
    scaler_X = StandardScaler()
    scaler_y = StandardScaler()

    X_train_scaled = scaler_X.fit_transform(X_train)
    X_test_scaled = scaler_X.transform(X_test)

    y_train_scaled = scaler_y.fit_transform(
        y_train.values.reshape(-1, 1)
    ).ravel()

    # --- Huấn luyện mô hình ---
    model = LinearRegression()
    model.fit(X_train_scaled, y_train_scaled)

    # --- Đánh giá trên tập test ---
    y_test_pred_scaled = model.predict(X_test_scaled)
    y_test_pred = scaler_y.inverse_transform(
        y_test_pred_scaled.reshape(-1, 1)
    ).ravel()

    test["DanSoDuBao_test"] = y_test_pred

    mae = mean_absolute_error(y_test, y_test_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_test_pred))
    r2 = r2_score(y_test, y_test_pred) if len(test) >= 2 else np.nan

    # --- Dự báo cho năm nam_chon ---
    row_target = gl_upto[gl_upto["Nam"] == nam_chon]
    if row_target.empty:
        raise ValueError(f"Không có dữ liệu lag cho năm {nam_chon}.")

    X_fc = scaler_X.transform(row_target[["DanSoTB_lag1"]])
    y_fc_scaled = model.predict(X_fc)
    du_bao_nam_chon = scaler_y.inverse_transform(
        y_fc_scaled.reshape(-1, 1)
    )[0, 0]

    # --- Kết quả ---
    summary_text = (
        f"Tỉnh: {tinh}\n"
        f"Năm dự báo: {nam_chon}\n"
        f"Mô hình: DanSoTB_t = b0 + b1 * DanSoTB_(t-1)\n"
        f"Đánh giá (test {test_years} năm cuối):\n"
        f"  - MAE : {mae:,.2f}\n"
        f"  - RMSE: {rmse:,.2f}\n"
        f"  - R2  : {r2:.4f}\n"
        f"Dự báo dân số năm {nam_chon}: {du_bao_nam_chon:.0f} người\n"
    )

    return {
        "summary_text": summary_text,
        "metrics": {"MAE": mae, "RMSE": rmse, "R2": r2},
        "test_table": test[["Nam", "DanSoTB_lag1", "DanSoTB", "DanSoDuBao_test"]],
        "forecast": {
            "nam_du_bao": nam_chon,
            "du_bao": du_bao_nam_chon
        },
        "model": model
    }


# =========================
# 3) Chạy thử
# =========================
if __name__ == "__main__":
    df = load_data("DataDanSoVN.csv")

    kq = ar1_train_test_forecast(
        df,
        tinh="HaNoi",
        nam_chon=2023,
        test_years=2
    )

    print(kq["summary_text"])
    print("BẢNG TEST:")
    print(kq["test_table"].to_string(index=False))

# =====================================================
# HỒI QUY ĐA BIẾN
# Sử dụng: DanSoTB_lag1, MatDoDS, DienTich
# Dự báo: DanSoTB
# =====================================================

import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from typing import List, Optional, Dict

FEATURES_DEFAULT: List[str] = ["DanSoTB_lag1", "MatDoDS", "DienTich"]

# 1. LOAD + TIỀN XỬ LÝ DỮ LIỆU
def load_and_preprocess(csv_path: str):
    df = pd.read_csv(csv_path)
    df["Nam"] = df["Nam"].astype(int)

    # Quy đổi dân số trung bình: nghìn người → người
    df["DanSoTB"] = df["DanSoTB"] * 1000
    return df

# 2. HÀM DỰ BÁO ĐA BIẾN
def du_bao_da_bien_lag1_matdo_dientich(
    df: pd.DataFrame,
    tinh: str,
    nam_chon: int,
    test_years: int = 2,
    features: Optional[List[str]] = None,
    x_nam_du_bao: Optional[Dict[str, float]] = None
):
    if features is None:
        features = FEATURES_DEFAULT

    # Lọc dữ liệu theo tỉnh
    g = df[df["Tinh"] == tinh].sort_values("Nam").copy()
    if g.empty:
        raise ValueError(f"Không tìm thấy tỉnh: {tinh}")

    #Tạo biến trễ(lag1 - là năm trước năm chọn dự báo )
    g["DanSoTB_lag1"] = g["DanSoTB"].shift(1)
    g = g.dropna().copy()

    #Chỉ dùng dữ liệu quá khứ
    g = g[g["Nam"] < nam_chon].copy()
    if len(g) < test_years + 2:
        raise ValueError("Không đủ dữ liệu để train/test")

    # Chia train / test theo thời gian
    train = g.iloc[:-test_years]
    test = g.iloc[-test_years:]

    X_train = train[features]
    y_train = train["DanSoTB"]

    X_test = test[features]
    y_test = test["DanSoTB"]

    # 3. CHUẨN HÓA
    scaler_X = StandardScaler()
    scaler_y = StandardScaler()

    X_train_scaled = scaler_X.fit_transform(X_train)
    X_test_scaled = scaler_X.transform(X_test)

    y_train_scaled = scaler_y.fit_transform(y_train.values.reshape(-1, 1)).ravel()

    # 4. HUẤN LUYỆN MÔ HÌNH
    model = LinearRegression()
    model.fit(X_train_scaled, y_train_scaled)

    # 5. ĐÁNH GIÁ MÔ HÌNH
    y_test_pred_scaled = model.predict(X_test_scaled)
    y_test_pred = scaler_y.inverse_transform(
        y_test_pred_scaled.reshape(-1, 1)
    ).ravel()

    mae = mean_absolute_error(y_test, y_test_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_test_pred))
    r2 = r2_score(y_test, y_test_pred) if len(test) >= 2 else np.nan

    test = test.copy()
    test["DanSoDuBao"] = y_test_pred

    # 6. DỰ BÁO NĂM CHỌN
    nam_truoc = nam_chon - 1
    if nam_truoc not in g["Nam"].values:
        raise ValueError(f"Không có dữ liệu năm {nam_truoc}")

    dan_so_lag1 = g.loc[g["Nam"] == nam_truoc, "DanSoTB"].iloc[0]

    row_future = df[(df["Tinh"] == tinh) & (df["Nam"] == nam_chon)]
    if not row_future.empty:
        matdo = row_future["MatDoDS"].iloc[0]
        dientich = row_future["DienTich"].iloc[0]
        source_inputs = "from_file"
    else:
        if x_nam_du_bao is None:
            raise ValueError("Thiếu MatDoDS và DienTich cho năm dự báo")
        matdo = x_nam_du_bao["MatDoDS"]
        dientich = x_nam_du_bao["DienTich"]
        source_inputs = "from_user"

    X_forecast = pd.DataFrame([{
        "DanSoTB_lag1": dan_so_lag1,
        "MatDoDS": matdo,
        "DienTich": dientich
    }])

    X_forecast_scaled = scaler_X.transform(X_forecast)
    du_bao_scaled = model.predict(X_forecast_scaled)

    du_bao = scaler_y.inverse_transform(
        du_bao_scaled.reshape(-1, 1)
    )[0][0]

    # 7. TỔNG HỢP KẾT QUẢ
    coef_lines = "\n".join(
        [f"  - {features[i]}: {model.coef_[i]:.6f}" for i in range(len(features))]
    )

    summary_text = (
        f"Tỉnh: {tinh}\n"
        f"Năm dự báo: {nam_chon}\n"
        f"Mô hình: DanSoTB_t = b0 + b1*DanSoTB_(t-1) + b2*MatDoDS + b3*DienTich\n"
        f"Hệ số:\n{coef_lines}\n"
        f"Đánh giá mô hình:\n"
        f"  - MAE : {mae:,.0f}\n"
        f"  - RMSE: {rmse:,.0f}\n"
        f"  - R2  : {r2:.4f}\n"
        f"Dự báo dân số năm {nam_chon}: {du_bao:.0f} người(Nguồn: {source_inputs})\n"
    )

    return {
        "summary_text": summary_text,
        "metrics": {"MAE": mae, "RMSE": rmse, "R2": r2},
        "test_table": test[["Nam"] + features + ["DanSoTB", "DanSoDuBao"]],
        "forecast": du_bao
    }

# 8. CHẠY THỬ
if __name__ == "__main__":
    df = load_and_preprocess("DataDanSoVN.csv")

    kq = du_bao_da_bien_lag1_matdo_dientich(
        df,
        tinh="HaNoi",
        nam_chon=2023,
        test_years=2
    )

    print(kq["summary_text"])
    print("BẢNG TEST 2 NĂM TRƯỚC CỦA NĂM ĐƯỢC CHỌN")
    print(kq["test_table"].to_string(index=False))
    """

#-------------------------------------------------------------------#
#giao dien
import tkinter as tk
from tkinter import messagebox
class DuBaoDanSoApp(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title("Chương trình dự đoán")
        self.geometry("520x260")
        self.resizable(False, False)

        self.create_widgets()
    def create_widgets(self):
        # ====== NHÓM NHẬP DỮ LIỆU ======
        frame_input = tk.LabelFrame(self, text="Nhập dữ liệu dự đoán")
        frame_input.pack(padx=10, pady=10, fill="x")

        # Tỉnh
        tk.Label(frame_input, text="Tỉnh").grid(row=0, column=0, padx=8, pady=6, sticky="w")
        self.entry_tinh = tk.Entry(frame_input, width=18)
        self.entry_tinh.grid(row=0, column=1, padx=8, pady=6)

        # Năm chọn
        tk.Label(frame_input, text="Năm chọn").grid(row=0, column=2, padx=8, pady=6, sticky="w")
        self.entry_nam = tk.Entry(frame_input, width=10)
        self.entry_nam.grid(row=0, column=3, padx=8, pady=6)

        # Số năm test
        tk.Label(frame_input, text="Số năm cần test").grid(row=1, column=0, padx=8, pady=6, sticky="w")
        self.entry_test_years = tk.Entry(frame_input, width=18)
        self.entry_test_years.grid(row=1, column=1, padx=8, pady=6)

        # ====== NHÓM CHỨC NĂNG ======
        frame_button = tk.LabelFrame(self, text="Chọn chức năng")
        frame_button.pack(padx=10, pady=10, fill="x")

        tk.Button(frame_button, text="Dự đoán", width=12, command=self.du_doan)\
            .grid(row=0, column=0, padx=10, pady=10)

        tk.Button(frame_button, text="Thoát", width=12, command=self.destroy)\
            .grid(row=0, column=3, padx=10, pady=10)

    # ====== XỬ LÝ SỰ KIỆN ======
    def du_doan(self):
        try:
            tinh = self.entry_tinh.get()
            nam = int(self.entry_nam.get())
            test_years = int(self.entry_test_years.get())

            kq = du_bao_da_bien_lag1_matdo_dientich(
                 df,
                 tinh=tinh,
                 nam_chon=nam,
                 test_years=test_years
             )

            # demo
            messagebox.showinfo("Kết quả", kq["summary_text"])


        except Exception as e:
            messagebox.showerror("Lỗi", str(e))


if __name__ == "__main__":
    app = DuBaoDanSoApp()
    app.mainloop()
    """

# =========================
# HỒI QUY ĐA BIẾN
# Sử dụng: TiSuatSinhTho, TiSuatTuTho, MatDoDS
# Dự báo: DanSoTB (năm chọn)
# =========================

import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler


# =========================
# 1) Đọc dữ liệu
# =========================
def load_data(csv_path: str) -> pd.DataFrame:
    df = pd.read_csv(csv_path)
    df["Nam"] = df["Nam"].astype(int)

    # Quy đổi dân số: nghìn người → người
    df["DanSoTB"] = df["DanSoTB"] * 1000
    return df


# =========================
# 2) Hồi quy đa biến + đánh giá + dự báo năm chọn
# =========================
def multivariate_model_forecast(
    df: pd.DataFrame,
    tinh: str,
    nam_chon: int,
    test_years: int = 2
):
    """
    Mô hình hồi quy đa biến:
        DanSoTB = b0
                  + b1 * TiSuatSinhTho
                  + b2 * TiSuatTuTho
                  + b3 * MatDoDS

    - Lọc theo tỉnh
    - Chỉ dùng dữ liệu ≤ năm chọn
    - Chia train/test theo thời gian
    - Chuẩn hóa dữ liệu
    - Đánh giá MAE, RMSE, R2
    - Dự báo DUY NHẤT cho năm nam_chon
    """

    # --- Lọc theo tỉnh ---
    g = df[df["Tinh"] == tinh].sort_values("Nam").copy()
    if g.empty:
        raise ValueError(f"Không tìm thấy tỉnh: {tinh}")

    # --- Giới hạn dữ liệu đến năm chọn ---
    g = g[g["Nam"] <= nam_chon].copy()

    features = ["TiSuatSinhTho", "TiSuatTuTho", "MatDoDS"]
    target = "DanSoTB"

    g = g.dropna(subset=features + [target])

    if len(g) < test_years + 2:
        raise ValueError("Không đủ dữ liệu để chia train/test.")

    # --- Chia train / test theo thời gian ---
    train = g.iloc[:-test_years].copy()
    test = g.iloc[-test_years:].copy()

    X_train = train[features]
    y_train = train[target]

    X_test = test[features]
    y_test = test[target]

    # --- Chuẩn hóa dữ liệu ---
    scaler_X = StandardScaler()
    scaler_y = StandardScaler()

    X_train_scaled = scaler_X.fit_transform(X_train)
    X_test_scaled = scaler_X.transform(X_test)

    y_train_scaled = scaler_y.fit_transform(
        y_train.values.reshape(-1, 1)
    ).ravel()

    # --- Huấn luyện mô hình ---
    model = LinearRegression()
    model.fit(X_train_scaled, y_train_scaled)

    # --- Dự đoán & đánh giá trên tập test ---
    y_test_pred_scaled = model.predict(X_test_scaled)
    y_test_pred = scaler_y.inverse_transform(
        y_test_pred_scaled.reshape(-1, 1)
    ).ravel()

    mae = mean_absolute_error(y_test, y_test_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_test_pred))
    r2 = r2_score(y_test, y_test_pred) if len(y_test) >= 2 else np.nan

    # --- Dự báo cho năm nam_chon ---
    row_target = g[g["Nam"] == nam_chon]
    X_forecast = scaler_X.transform(row_target[features])
    y_forecast_scaled = model.predict(X_forecast)
    du_bao_nam_chon = scaler_y.inverse_transform(
        y_forecast_scaled.reshape(-1, 1)
    )[0, 0]

    # --- Kết quả ---
    summary_text = (
        f"Tỉnh: {tinh}\n"
        f"Năm dự báo: {nam_chon}\n"
        f"Mô hình hồi quy đa biến:\n"
        f"DanSoTB = b0 + b1*TiSuatSinhTho + b2*TiSuatTuTho + b3*MatDoDS\n"
        f"Đánh giá (test {test_years} năm cuối):\n"
        f"  - MAE : {mae:,.2f}\n"
        f"  - RMSE: {rmse:,.2f}\n"
        f"  - R2  : {r2:.4f}\n"
        f"Dự báo dân số năm {nam_chon}: {du_bao_nam_chon:,.0f} người\n"
    )

    return {
        "summary_text": summary_text,
        "metrics": {"MAE": mae, "RMSE": rmse, "R2": r2},
        "forecast": {
            "nam_du_bao": nam_chon,
            "du_bao": du_bao_nam_chon
        },
        "model": model
    }


# =========================
# 3) Chạy thử
# =========================
if __name__ == "__main__":
    df = load_data("DataDanSoVN.csv")

    kq = multivariate_model_forecast(
        df,
        tinh="HaNoi",
        nam_chon=2023,
        test_years=2
    )

    print(kq["summary_text"])

# GIAO DIỆN CƠ BẢN ĐA BIẾN
import tkinter as tk
from tkinter import messagebox
class DuBaoDanSoApp(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title("Chương trình dự đoán")
        self.geometry("520x260")
        self.resizable(False, False)

        self.create_widgets()
    def create_widgets(self):
        # ====== NHÓM NHẬP DỮ LIỆU ======
        frame_input = tk.LabelFrame(self, text="Nhập dữ liệu dự đoán")
        frame_input.pack(padx=10, pady=10, fill="x")

        # Tỉnh
        tk.Label(frame_input, text="Tỉnh").grid(row=0, column=0, padx=8, pady=6, sticky="w")
        self.entry_tinh = tk.Entry(frame_input, width=18)
        self.entry_tinh.grid(row=0, column=1, padx=8, pady=6)

        # Năm chọn
        tk.Label(frame_input, text="Năm chọn").grid(row=0, column=2, padx=8, pady=6, sticky="w")
        self.entry_nam = tk.Entry(frame_input, width=10)
        self.entry_nam.grid(row=0, column=3, padx=8, pady=6)

        # Số năm test
        tk.Label(frame_input, text="Số năm cần test").grid(row=1, column=0, padx=8, pady=6, sticky="w")
        self.entry_test_years = tk.Entry(frame_input, width=18)
        self.entry_test_years.grid(row=1, column=1, padx=8, pady=6)

        # ====== NHÓM CHỨC NĂNG ======
        frame_button = tk.LabelFrame(self, text="Chọn chức năng")
        frame_button.pack(padx=10, pady=10, fill="x")

        tk.Button(frame_button, text="Dự đoán", width=12, command=self.du_doan)\
            .grid(row=0, column=0, padx=10, pady=10)

        tk.Button(frame_button, text="Thoát", width=12, command=self.destroy)\
            .grid(row=0, column=3, padx=10, pady=10)

    # ====== XỬ LÝ SỰ KIỆN ======
    def du_doan(self):
        try:
            tinh = self.entry_tinh.get()
            nam = int(self.entry_nam.get())
            test_years = int(self.entry_test_years.get())

            kq = du_bao_da_bien_lag1_matdo_dientich(
                 df,
                 tinh=tinh,
                 nam_chon=nam,
                 test_years=test_years
             )

            # demo
            messagebox.showinfo("Kết quả", kq["summary_text"])


        except Exception as e:
            messagebox.showerror("Lỗi", str(e))


if __name__ == "__main__":
    app = DuBaoDanSoApp()
    app.mainloop()

#QUY ĐỔI ĐƠN VỊ VÀ CHUẨN HÓA - MA TRẬN TƯƠNG QUAN
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler

# Đọc dữ liệu
df = pd.read_csv("DataDanSoVN.csv")

# Kiểm tra thông tin dữ liệu
print(df.info())
# Kiểm tra giá trị thiếu
print(df.isnull().sum())

# Sao chép dữ liệu để tránh làm thay đổi dữ liệu gốc
df_scaled = df.copy()

# Khởi tạo StandardScaler
scaler = StandardScaler()

# Quy đổi dân số trung bình từ đơn vị nghìn người sang người
df["DanSoTB"] = df["DanSoTB"] * 1000

# Danh sách các thuộc tính số cần chuẩn hóa
num_cols = [
    "DienTich",
    "DanSoTB",
    "MatDoDS",
    "TiSuatTuTho",
    "TiSuatSinhTho",
    "TiLeBietChu",
    "TiLeTangTN",
    "TiSuatNhapCu",
    "TiSuatXuatCu"
]

# Thực hiện chuẩn hóa
df_scaled[num_cols] = scaler.fit_transform(df[num_cols])

# Kiểm tra kết quả sau chuẩn hóa
print(df_scaled[num_cols])

# Tính ma trận tương quan
corr_matrix = df[num_cols].corr()

# Vẽ biểu đồ ma trận tương quan
plt.figure(figsize=(8, 6))
plt.imshow(corr_matrix)
plt.colorbar()
plt.xticks(range(len(num_cols)), num_cols, rotation=90)
plt.yticks(range(len(num_cols)), num_cols)
plt.title("Ma trận tương quan giữa các thuộc tính dân số")
plt.tight_layout()
plt.show()



